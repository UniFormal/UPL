module similarTriangles_gameplay_example{
//The Background Theory declaring all relevant types and functions
type point
dist: point -> point -> float
angle_math_order: point -> point -> point -> float
// The arguments are reordered, to put the vertex first. This way currying can be used to guarantee some identities.
angle: point -> point -> point -> float 
  = B -> C -> A -> angle_math_order(A)(B)(C)
theory triangle{
  a: point
  b: point
  c: point
}
similar: triangle -> triangle -> bool
/////

/////
// The facts all have useful names. They certainly wouldn't be generated this way, so let's just claim the user can rename them. 
/////
theory S1{
  tip: point
  foot: point
  ground: point
}

theory S2{
  include S1
  //             tip
  //           ,´ |
  //          p   |
  //        ,´|   |
  //  ground--q--foot
  p: point
  q: point
  ground_dist_small:  |- dist(ground)(q) == 0.815
  ground_dist_large:  |- dist(ground)(foot) == 08.15
  apparent_height: |- dist(p)(q) == 0.815
  are_similar: |- similar(triangle{a=tip, b=ground, c=foot})(triangle{a=p, b=ground, c=q})
}

// theory _simTri_Scroll{
//   //             A
//   //           ,´|
//   //          B  |
//   //        ,´|  |
//   //       C--D--E

//   _A: point
//   _B: point
//   _C: point
//   _D: point
//   _E: point
//   _RA_C: |- angle(_C)(_A)(_B) == 90.0
//   _AngleAtB: |- angle(_B)(_C)(_A) == ???
//   _BC: |- dist(_B)(_C) == ???

//   // The solution of the scroll. Recognizable by 
//   // - having a definiens (hypothetically)
//   // - starting with a double underscore
//   __CA: |- dist(_C)(_A) == tan(angle(_A)(_B)(_C)) * dist(_B)(_C)
//   //=~ |- dist(C)(A) ==_float (dist(C)(A) / dist(B)(C)) * dist(B)(C)
// }

// ///////////
// // Approach 1: Equate the Slots in a temporary Theory
// // 1. Generate `Slot_equations`
// // 2. `solve()` the `Slot_equations`, and
// // 3. Adequately rename the solution(s)
// // 4. `S3_1` is generated by removing all helper declarations (i.e. everything involving a name starting with an underscore) from the result
// //////////

// theory Slot_equations{
//   include S2
//   include _OpLen_Scroll
//   _A = tip
//   _B = foot
//   _C = ground
//   // UPL currently can't handle those assignments
//   //_AngleAtB = measured_Angle
//   //_RA_C = rightAngle
//   //_BC = ground_dist
// }

// theory S3_1{
//   include S2
//   height: |- dist(foot)(tip) == 0.815
// }

// ///////////
// // Approach 2: Equate the Slots in the meta
// // 1. Generate a temporary _OpLen_Instance with renamed variables
// // 2. `S3` is generated by `include S2 \n include _OpLen_Instance`, because
// //  2.1. UPL definition-merging (should) take care of the solving
// //  2.2. No helper declarations are needed
// //
// // This looks "too perfect" in this example, because
// // 1. `S2` literally only contains facts relevant for the Scroll
// // 2. The challenging part is actually generating it 
// //////////

// theory _OpLen_Instance{
//   foot: point
//   tip: point
//   ground: point
//   rightAngle: |- angle(foot)(tip)(ground) == 90.0
//   measured_Angle: |- angle(ground)(tip)(foot) == 45.0
//   ground_dist:  |- dist(ground)(foot) == 0.815

//   CA: |- dist(foot)(tip) == tan(angle(ground)(tip)(foot)) * dist(ground)(foot)
//   //=~ |- dist(R)(P) ==_float (dist(R)(P) / dist(Q)(R)) * dist(Q)(R)
// }

// theory S3_2{
//   include S2 
//   include _OpLen_Instance
// }

}