module opLen_gameplay_example{
//The Background Theory declaring all relevant types and functions
type point

tan: float -> float
dist: point -> point -> float
angle_math_order: point -> point -> point -> float
// The arguments are reordered, to put the vertex first. This way currying can be used to guarantee some identities.
angle: point -> point -> point -> float 
  = B -> C -> A -> angle_math_order(A)(B)(C)
/////
theory FactKind{
  type t
  type univ = (a:t, b:t, |- a==b)
  t_factMaker: (t,t) -> univ
  t_factMaker = (a,b) -> (a,b, ???)
}
floatFact = FactKind{type t = float}
/////
// The facts all have useful names. They certainly wouldn't be generated this way, so let's just claim the user can rename them. 
/////

theory S1{
  tip: point
  foot: point
  ground: point
}

theory S2{
  include S1
  ground_dist:  |- dist(ground)(foot) == 0.815
  rightAngle: |- angle(foot)(tip)(ground) == 90.0
  measured_Angle: |- angle(ground)(tip)(foot) == 45.0

  // experimental
  //ground_dist2: floatFact = isEq(dist(ground)(foot), 0.815)
  //t:_ = ground_dist2(1)
}

theory _OpLen_Scroll{
  //          A
  //         /|
  //        / |
  //       B--C

  _A: point
  _B: point
  _C: point
  _RA_C: |- angle(_C)(_A)(_B) == 90.0
  // How to write down the equalities if the value is unknown?
  _AngleAtB: |- angle(_B)(_C)(_A) == ???
  _BC: |- dist(_B)(_C) == ???

  // The solution of the scroll. Recognizable by 
  // - having a definiens (hypothetically)
  // - starting with a double underscore
  __CA: |- dist(_C)(_A) == tan(angle(_A)(_B)(_C)) * dist(_B)(_C)
  //=~ |- dist(C)(A) ==_float (dist(C)(A) / dist(B)(C)) * dist(B)(C)
}
theory S3{
  include S2
  theory _OpLen_instance{
    //          A
    //         /|
    //        / |
    //       B--C
    // A,B,C are already instanciated
    // _A: point
    // _B: point
    // _C: point
    _RA_C: |- angle(foot)(tip)(ground) == 90.0
    // How to write down the equalities if the value is unknown?
    _AngleAtB: |- angle(ground)(tip)(foot) == 45.0
    _BC: |- dist(ground)(foot) == 0.815

    // The solution of the scroll. Recognizable by 
    // - having a definiens (hypothetically)
    // - starting with a double underscore
    __CA: |- dist(foot)(tip) == tan(angle(tip)(ground)(foot)) * dist(ground)(foot)
    //=~ |- dist(C)(A) ==_float (dist(C)(A) / dist(B)(C)) * dist(B)(C)
    // __CA = ??? // Not in physical theory
  }
  test1:_ = _OpLen_instance.__CA
}

///////////
// Approach 1: Equate the Slots in a temporary Theory
// 1. Generate `Slot_equations`
// 2. `solve()` the `Slot_equations`, and
// 3. Adequately rename the solution(s)
// 4. `S3_1` is generated by removing all helper declarations (i.e. everything involving a name starting with an underscore) from the result
//////////

theory Slot_equations{
  include S2
  include _OpLen_Scroll
  _A = tip
  _B = ground
  _C = foot
  // Can't handle those assignments currently
  //_RA_C = rightAngle
  // _AngleAtB = measured_Angle
  // _BC = ground_dist
}

// solve(Slot_equations)
theory S2point5{
  include S2
  __CA: |- dist(foot)(tip) == 0.815
}

// some renaming magic(S2point5)
theory S3_1{
  include S2
  height: |- dist(foot)(tip) == 0.815
}

///////////
// Approach 2: Equate the Slots in the meta
// 1. Generate a temporary _OpLen_Instance with renamed variables
// 2. `S3` is generated by `include S2 \n include _OpLen_Instance`, because
//  2.1. UPL definition-merging (should) take care of the solving
//  2.2. No helper declarations are needed
//
// This looks "too perfect" in this example, because
// 1. `S2` literally only contains facts relevant for the Scroll
// 2. The challenging part is actually generating it 
//////////

theory _OpLen_Instance{
  foot: point
  tip: point
  ground: point
  rightAngle: |- angle(foot)(tip)(ground) == 90.0
  measured_Angle: |- angle(ground)(tip)(foot) == 45.0
  ground_dist:  |- dist(ground)(foot) == 0.815

  solution_height: |- dist(foot)(tip) == tan(angle(ground)(tip)(foot)) * dist(ground)(foot)
  //=~ |- dist(R)(P) ==_float (dist(R)(P) / dist(Q)(R)) * dist(Q)(R)
}

theory S3_2{
  include S2 
  include _OpLen_Instance
}

}