module treeWorld_usingFunctions_simple{

tan: float -> float

module BackgroundTheory{
  type point
  dist: point -> point -> float
  angle: point -> point -> point -> float
}
///////////
// The actual points are called "P", "Q" and "R", to make them clearly distinct from the abstract points in the Scroll.
///////////
theory S1{
  include BackgroundTheory
  // The actual points are called "P", "Q" and "R", to make them clearly distinct from the abstract points in the Scroll.
  P: point
  Q: point
  R: point
}

theory S2{
  include S1
  QR:  |- dist(Q)(R) == 0.815
  PQR: |- angle(P)(Q)(R) == 45.0
  QRP: |- angle(Q)(R)(P) == 90.0
}

theory _OpLen_Scroll{
  include BackgroundTheory

  //////// Helpers to make `_AngleAtB` and `_BC` possible to write down.
  _Beta: float
  _Dist_BC: float
  ////////

  _A: point
  _B: point
  _C: point
  _RA_C: |- angle(_B)(_C)(_A) == 90.0
  _AngleAtB: |- angle(_A)(_B)(_C) == _Beta
  _BC: |- dist(_B)(_C) == _Dist_BC

  // The solution of the scroll. Recognizable by 
  // - having a definiens (hypothetically)
  // - starting with a double underscore
  __CA: |- dist(_C)(_A) == tan(angle(_A)(_B)(_C)) * dist(_B)(_C)
  //=~ |- dist(C)(A) ==_float (dist(C)(A) / dist(B)(C)) * dist(B)(C)
}

///////////
// Approach 1: Equate the Slots in a temporary Theory
// 1. generate `Slot_equations`
// 2. `solve()` the `Slot_equations`, and
// 3. adequately rename the solution(s)
// 4. `S3` is generated by removing all helper declarations (i.e. everything involving a name starting with an underscore) from the result
//////////

theory Slot_equations{
  include S2
  include _OpLen_Scroll
  _A = P
  _B = Q
  _C = R
  _Beta = 45.0
  _Dist_BC = 0.815
  // UPL currently can't handle those assignments
  //_AngleAtB = PQR
  //_RA_C = QRP
  //_BC = QR
}

theory S3_1{
  include S2
  RP: |- dist(R)(P) == 0.815
}

///////////
// Approach 2: Equate the Slots in the meta
// 1. generate a temporary _OpLen_Instance with renamed variables
// 2. `S3` is generated by `include S2 \n include _OpLen_Instance`, because
//  2.1. UPL definition-merging (should) take care of the solving
//  2.2. No helper declarations are needed
//
// This looks "too perfect" in this example, because
// 1. `S2` literally only contains facts relevant for the Scroll
// 2. 
//////////

theory _OpLen_Instance{
  include BackgroundTheory

  //////// Helpers to make `_AngleAtB` and `_BC` possible to write down.
  // _Beta: float
  // _Dist_BC: float
  ////////
  P: point
  Q: point
  R: point
  QRP: |- angle(Q)(R)(P) == 90.0
  PQR: |- angle(P)(Q)(R) == 45.0
  QR:  |- dist(Q)(R) == 0.815

  RP: |- dist(R)(P) == tan(angle(P)(Q)(R)) * dist(Q)(R)
  //=~ |- dist(R)(P) ==_float (dist(R)(P) / dist(Q)(R)) * dist(Q)(R)
}

theory S3_2{
  include S2 
  include _OpLen_Instance
}

}