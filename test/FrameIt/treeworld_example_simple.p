module treeWorld_usingFunctions_simple{

tan: float -> float

module BackgroundTheory{
  type point
  dist: point -> point -> float
  angle: point -> point -> point -> float
}
///////////
// The actual points are called "P", "Q" and "R", to make them clearly distinct from the abstract points in the Scroll.
///////////
theory S1{
  include BackgroundTheory
  // The actual points are called "P", "Q" and "R", to make them clearly distinct from the abstract points in the Scroll.
  P: point
  Q: point
  R: point
}

theory S2{
  include S1
  QR:  |- dist(Q)(R) == 0.815
  PQR: |- angle(P)(Q)(R) == 45.0
  QRP: |- angle(Q)(R)(P) == 90.0
}

theory _OpLen_Scroll{
  include BackgroundTheory

  //////// Helpers to make `_AngleAtB` and `_BC` possible to write down.
  _Beta: float
  _Dist_BC: float
  ////////

  _A: point
  _B: point
  _C: point
  _RA_C: |- angle(_B)(_C)(_A) == 90.0
  _AngleAtB: |- angle(_A)(_B)(_C) == _Beta
  _BC: |- dist(_B)(_C) == _Dist_BC

  // The solution of the scroll. Recognizable by 
  // - having a definiens (hypothetically)
  // - starting with a double underscore
  __CA: |- dist(_C)(_A) == tan(angle(_A)(_B)(_C)) * dist(_B)(_C)
  //=~ |- dist(C)(A) ==_float (dist(C)(A) / dist(B)(C)) * dist(B)(C)
}

///////////
// Approach 1: Equate the Slots in a temporary Theory
// 1. generate `Slot_equations`
// 2. `solve()` the `Slot_equations`, and
// 3. adequately rename the solution(s)
// 4. `S3` is generated by removing all helper declarations (i.e. everything involving a name starting with an underscore) from the result
//////////

theory Slot_equations{
  include S2
  include _OpLen_Scroll
  _A = P
  _B = Q
  _C = R
  _Beta = 45.0
  _Dist_BC = 0.815
  // UPL currently can't handle those assignments
  //_AngleAtB = PQR
  //_RA_C = QRP
  //_BC = QR
}

theory S3_1{
  include S2
  RP: |- dist(R)(P) == 0.815
}

///////////
// Approach 2: Equate the Slots in the meta
// 1. generate a temporary _OpLen_Instance with renamed variables
// 2. `S3` is generated by `include S2 \n include _OpLen_Instance`, because
//  2.1. UPL definition-merging (should) take care of the solving
//  2.2. No helper declarations are needed
//
// This looks "too perfect" in this example, because
// 1. `S2` literally only contains facts relevant for the Scroll
// 2. 
//////////

theory _OpLen_Instance{
  include BackgroundTheory

  //////// Helpers to make `_AngleAtB` and `_BC` possible to write down.
  // _Beta: float
  // _Dist_BC: float
  ////////
  P: point
  Q: point
  R: point
  QRP: |- angle(Q)(R)(P) == 90.0
  PQR: |- angle(P)(Q)(R) == 45.0
  QR:  |- dist(Q)(R) == 0.815

  RP: |- dist(R)(P) == tan(angle(P)(Q)(R)) * dist(Q)(R)
  //=~ |- dist(R)(P) ==_float (dist(R)(P) / dist(Q)(R)) * dist(Q)(R)
}

theory S3_2{
  include S2 
  include _OpLen_Instance
}

}

module Monday {

theory Situation {
  p1: point // unknown coordinates
  p2: point
  p3: point
  angle1: float = ... // measured value
  angle1_construction: |- angle1 == angle(p1,p2,p3) // axiom capturing construction of the value
  angle2: float
  angle2_construction: |- angle1 == angle(p2,p1,p3)
  dist1: float = ... // measured value
  dist1_construction: |- dist1 == dist(p1,p2)
}

theory Situation3 {
  p1: point // unknown coordinates
  p2: point
  p3: point
  angle1: float = angle(p1,p2,p3) => (measured value)
  angle2: float = angle(p2,p1,p3) => (measured value)
  dist1: float = dist(p1,p2) => (measured value)
}

theory Situation4 {
  p1: point // unknown coordinates
  p2: point
  p3: point
  angle1: the angle(p1,p2,p3) = (measured value)
  dist1:  the dist(p1,p2) = (measured value)

  angle2: the angle(p2,p1,p3) = (measured value)
  // alternatively if the user confirmed right angle instead of measuring
  p1p2_right: rightangle(angle2)
}

theory Scroll4 {
  bottom: point
  top: point
  observer: point
  observer_angle: the angle(top,observer,bottom)
  observer_distance: the dist(observer,bottom)
  right_angle: |- rightangle(angle(top,bottom,observer))
  height: the dist(bottom,top) = observer_distance * tan(observer_angle)
}

theory Scroll4Apllication_as_built {
  include Situation4
  include Scroll4
  bottom = p1
  top = p2
  observer = p3
  observer_angle = angle1
  observer_distance = dist1
  right_angle = p1p1_right
}

theory Scroll4Apllication_as_flattened_and_simplified {
  include Situation4
  realize Scroll4
  bottom = p1
  top = p2
  observer = p3
  observer_angle = angle1
  observer_distance = dist1
  right_angle = (trueI infered after calcuation) // alternatively: p1p2_right
  height: the dist(bottom,top) = (calculated value)
}


theory Scroll3 {
  bottom: point
  top: point
  observer: point
  observer_angle = angle(top,observer,bottom)
  observer_distance = dist(observer,bottom)
  right_angle: |- rightangle(angle(top,bottom,observer))
  height = dist(bottom,top)
  height_def: |- height == observer_distance * tan(observer_angle)
}

theory Scroll2 {
  a: float
  b: float
  c: float
  alpha: float
  beta: float
  gamma: float
  // triangle axioms
}

theory Scroll2Application {
  include Situation
  include Scroll2
  a = dist1
  alpha = angle1
  beta = angle2
}

theory Scroll1 {
  bottom: point
  top: point
  observer: point
  observer_angle: float
  observer_angle_def: |- observer_angle == angle(top,observer,bottom)
  observer_distance: float
  observer_distance_def: |- observer_distance == dist(observer,bottom)
  right_angle: |- rightangle(angle(top,bottom,observer))
  height = observer_distance * tan(observer_angle)
  height_def: |- height == dist(bottom,top) = ???
}

theory Scroll1Application_as_Built {
  include Situation
  realize Scroll
  bottom = p1
  top = p2
  observer = p3
  observer_angle = angle1
  observer_distance = dist1
}

theory Scroll1Application_as_flattened_internally {
  include Situation
  realize Scroll
  bottom = p1
  top = p2
  observer = p3
  observer_angle = angle1
  observer_distance = dist1
  // automatically found proofs
  observer_angle_def = angle1_construction
  observer_distance_def = observer_distance_def
  right_angle = ... // requires some calculation
  height = ... // calculated value
  height_def: |- height == dist(bottom,top)
}

theory Scroll1_bigstep {
  bottom: point
  top: point
  observer: point
  observer_angle: float
  observer_angle_def: |- observer_angle == angle(top,observer,bottom)
  observer_distance: float
  observer_distance_def: |- observer_distance == dist(observer,bottom)
  right_angle: |- rightangle(angle(top,bottom,observer))

  height: float
  height_def: |- height == dist(bottom,top)
  // same for other values of the triangle like topangle, distance_to_top
  ...

  // all other triangle laws
  height_by_tan: |- height = observer_distance * tan(observer_angle)
  ...

}

theory Scroll1_bigstep_Application_as_Built {
  include Situation
  include Scroll
  bottom = p1
  top = p2
  observer = p3
  observer_angle = angle1
  observer_distance = dist1
  observer_angle_def = ???
  observer_distance_def = ???
  
  // other fields
}

theory Scroll1_bigstep_Application_as_solved {
  include Situation
  include Scroll
  bottom = p1
  top = p2
  observer = p3
  observer_angle = angle1
  observer_distance = dist1
  height = ... // solved value
  
  // other fields
}

}